"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const util = require("util");
const request = require("request");
const zlib = require("zlib");
const split = require("split");
const stream = require("stream");
const writeFile = util.promisify(fs.writeFile);
const readFile = util.promisify(fs.readFile);
class B2ArchiveFile {
    constructor(path) {
        this.path = path;
    }
    inspect(forceReload = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!forceReload && this.meta) {
                return this.meta;
            }
            const meta = {
                providers: []
            };
            yield this.walkObjects(data => {
                let p = meta.providers.find(p => p.id === data.id);
                if (!p) {
                    p = {
                        id: data.id,
                        objects: 0
                    };
                    meta.providers.push(p);
                }
                p.objects++;
            });
            return meta;
        });
    }
    walkObjects(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const gunzip = zlib.createGunzip();
            const ts = new stream.Transform({
                transform(chunk, encoding, callback) {
                    fn(chunk);
                    callback(null, chunk);
                },
                objectMode: true
            });
            return new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(gunzip)
                    .on("error", reject)
                    .pipe(split(JSON.parse, null, { trailing: false }))
                    .on("error", reject)
                    .pipe(ts)
                    .on("error", reject)
                    .on("data", () => { })
                    .on("end", function () {
                    resolve();
                });
            });
        });
    }
    transformAndPipe(fn, w) {
        return __awaiter(this, void 0, void 0, function* () {
            const gunzip = zlib.createGunzip();
            const gzip = zlib.createGzip();
            const ts = new stream.Transform({
                transform(chunk, encoding, callback) {
                    callback(null, JSON.stringify(fn(chunk)) + "\n");
                },
                objectMode: true
            });
            return new Promise((resolve, reject) => {
                fs.createReadStream(this.path)
                    .pipe(gunzip)
                    .on("error", reject)
                    .pipe(split(JSON.parse, null, { trailing: false }))
                    .on("error", reject)
                    .pipe(ts)
                    .on("error", reject)
                    .pipe(gzip)
                    .on("error", reject)
                    .pipe(w)
                    .on("error", reject)
                    .on("end", function () {
                    resolve();
                });
            });
        });
    }
    getTypes() {
        return __awaiter(this, void 0, void 0, function* () {
            const meta = yield readFile(`${this.path}.metadata.json`, "utf8");
            return JSON.parse(meta)["source"]["types"];
        });
    }
}
exports.B2ArchiveFile = B2ArchiveFile;
function getModuleIdTypeMap(meta) {
    const idModuleMap = {};
    Object.keys(meta.allModules).forEach(type => {
        const insts = meta.allModules[type];
        insts.forEach(inst => {
            if (inst.id) {
                idModuleMap[inst.id] = type;
            }
        });
    });
    return idModuleMap;
}
class B2Archive {
    constructor(client) {
        this.c = client;
        this.path = `/archive`;
    }
    inspect() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const [providers, remotes] = yield Promise.all([
                    this.c.request("GET", `${this.path}/provider`),
                    this.c.request("GET", `${this.path}/remote`)
                ]);
                return {
                    providers,
                    remotes
                };
            }
            catch (e) {
                if (e.status === 404) {
                    throw new Error("Archive module was not found");
                }
                else {
                    throw e;
                }
            }
        });
    }
    writeMetaFile(path, metadata) {
        return __awaiter(this, void 0, void 0, function* () {
            const filepath = path + ".metadata.json";
            return writeFile(filepath, JSON.stringify({
                source: {
                    endpoint: this.c.endpoint,
                    types: getModuleIdTypeMap(yield this.c.inspect())
                },
                metadata
            }, null, "  "), "utf8");
        });
    }
    exportArchive(archivePath, providers = null) {
        return __awaiter(this, void 0, void 0, function* () {
            yield new Promise((resolve, reject) => {
                request({
                    url: `${this.c.endpoint}${this.path}/export`,
                    qs: this.c.configureQuery(providers
                        ? {
                            provider: providers
                        }
                        : {}),
                    useQuerystring: true
                })
                    .on("error", reject)
                    .pipe(fs.createWriteStream(archivePath))
                    .on("error", reject)
                    .on("finish", () => {
                    resolve();
                });
            });
            const af = new B2ArchiveFile(archivePath);
            const meta = yield af.inspect();
            yield this.writeMetaFile(archivePath, meta);
        });
    }
    getRedirectChecker() {
        return __awaiter(this, void 0, void 0, function* () {
            const meta = yield this.c.inspect();
            const idModuleMap = getModuleIdTypeMap(meta);
            return (id, type) => {
                if (!id) {
                    throw new Error(`Invalid archive file, some object does not have an id`);
                }
                if (!type) {
                    throw new Error(`Invalid archive file, an invalid type '${type}' was found`);
                }
                if (!(id in idModuleMap)) {
                    return;
                }
                const moduleType = idModuleMap[id];
                if (moduleType !== type) {
                    throw new Error(`Can not push data to provider '${id}', type in archive is '${type}' but B2 expects type '${moduleType}'`);
                }
            };
        });
    }
    importArchive(archivePath, redirect = id => id) {
        return __awaiter(this, void 0, void 0, function* () {
            const checkType = yield this.getRedirectChecker();
            const a = new B2ArchiveFile(archivePath);
            const types = yield a.getTypes();
            return new Promise((resolve, reject) => {
                let rejected = false;
                const tryReject = (err) => {
                    if (rejected) {
                        return;
                    }
                    rejected = true;
                    reject(err);
                };
                const req = request
                    .put({
                    url: `${this.c.endpoint}${this.path}/apply`,
                    qs: this.c.configureQuery({})
                })
                    .on("response", res => {
                    let body = "";
                    res
                        .on("error", tryReject)
                        .on("data", (data) => {
                        body += data.toString("utf8");
                    })
                        .on("end", () => {
                        if (res.statusCode !== 200) {
                            return tryReject({
                                message: `${res.statusMessage}`,
                                body
                            });
                        }
                        try {
                            return resolve(JSON.parse(body));
                        }
                        catch (e) {
                            return tryReject(e);
                        }
                    });
                });
                a.transformAndPipe(obj => {
                    if (obj.id !== "auth" && obj.id.indexOf("asset:") !== 0) {
                        checkType(obj.id, types[obj.id]);
                        obj.id = redirect(obj.id);
                    }
                    return obj;
                }, req).then(null, tryReject);
            });
        });
    }
}
exports.B2Archive = B2Archive;
//# sourceMappingURL=archive.js.map