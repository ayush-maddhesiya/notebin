"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const client_1 = require("./client");
const config_1 = require("./config");
const file_1 = require("./file");
const controller_1 = require("./controller");
const schema_1 = require("./schema");
const archive_1 = require("./archive");
const env_1 = require("./env");
const asset_1 = require("./asset");
class B2Entry {
    constructor(c, meta, hasAsset) {
        this.meta = meta;
        let { path, refs } = meta;
        const isPageModuleRef = refs.includes("page");
        path = path === "/" ? "/__root" : path;
        this._path = path;
        this._file = new file_1.B2File(c, path, isPageModuleRef);
        this._controller = new controller_1.B2Controller(c, path, isPageModuleRef);
        this._schema = new schema_1.B2Schema(c, path, refs.includes("schema"));
        this._env = new env_1.B2Env(c, path, refs.includes("basics"));
        if (hasAsset) {
            this._asset = new asset_1.B2Asset(c, `${path}/asset`);
        }
    }
    get name() {
        return this.meta.name;
    }
    get path() {
        return this._path;
    }
    get file() {
        return this._file;
    }
    get controller() {
        return this._controller;
    }
    get schema() {
        return this._schema;
    }
    get env() {
        return this._env;
    }
    get asset() {
        return this._asset;
    }
}
exports.B2Entry = B2Entry;
class B2 {
    constructor(config) {
        this.c = new client_1.B2Client(config);
        this._archive = new archive_1.B2Archive(this.c);
        this._asset = new asset_1.B2Asset(this.c);
        this.entryMap = new Map();
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.meta = yield this.c.inspect();
            this.meta.entries.forEach(entry => {
                const asset = this.meta.allModules["asset"].find(a => a.path === entry.path || (a.path === "__root" && entry.path === "/"));
                this.entryMap.set(entry.name, new B2Entry(this.c, entry, !!asset));
            });
        });
    }
    get publicURL() {
        return this.meta.publicURL;
    }
    get entries() {
        return this.meta.entries;
    }
    get name() {
        return this.meta.name;
    }
    get referencedModules() {
        return this.meta.referencedModules;
    }
    get modules() {
        return this.meta.allModules;
    }
    get archive() {
        return this._archive;
    }
    get asset() {
        return this._asset;
    }
    entry(name) {
        const e = this.entryMap.get(name);
        if (!e) {
            const names = Array.from(this.entryMap.keys())
                .map(name => `'${name}'`)
                .join(", ");
            throw new Error(`Entry '${name}' was not found. Avaliable entries are: ${names}`);
        }
        return e;
    }
}
exports.B2 = B2;
function connect(config) {
    return __awaiter(this, void 0, void 0, function* () {
        let b2;
        if (typeof config === "string") {
            b2 = new B2(yield config_1.readConfig(config));
        }
        else {
            b2 = new B2(config);
        }
        yield b2.init();
        return b2;
    });
}
exports.connect = connect;
//# sourceMappingURL=index.js.map