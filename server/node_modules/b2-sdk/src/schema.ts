import { B2Client } from "./client";

export interface SchemaListEntry {
  id?: string;
  handle: string;
  name: string;
  icon?: string;
  show_nav_item?: boolean;
  module_schema_id?: string;
  table_name?: string;
  created_at?: string;
  updated_at?: string;
}

export enum DataType {
  "string" = "string",
  "number" = "number",
  "boolean" = "boolean",
  "array" = "array",
  "object" = "object"
}

export enum FormatterType {
  "date" = "date",
  "currency" = "currency"
}
export interface SchemaEntryProp {
  key: string;
  type: DataType;
  label: string;
  item?: SchemaArrayItemProp;
  grid_size?: GridSize;
  grid_clear_left?: boolean;
  helper_text?: string;
  editor_type?: EditorType;
  height?: string;
  editing?: boolean;
  formatter_type?: FormatterType;
  formatter_currency_prefix?: string;
  display_in_list?: boolean;
  searchable?: boolean;
  string_match_message?: string;
  string_max_length?: number;
  dropdown_options?: DropdownOption[];
}

export enum EditorType {
  "textbox" = "textbox",
  "dropdown" = "dropdown",
  "file" = "file",
  "checkbox" = "checkbox",
  "code" = "code",
  "none" = "none"
}

export type DropdownOption = {
  label: string;
  value: string;
};

export enum GridSize {
  "size_1" = "1",
  "size_2" = "2",
  "size_3" = "3",
  "size_4" = "4",
  "size_5" = "5",
  "size_6" = "6",
  "size_7" = "7",
  "size_8" = "8",
  "size_9" = "9",
  "size_10" = "10",
  "size_11" = "11",
  "size_12" = "12",
  "size_default" = "default"
}

export interface SchemaArrayItemProp {
  dropdown_options?: DropdownOption[];
  editor_type?: EditorType;
  grid_clear_left?: boolean;
  grid_size?: GridSize;
  type: DataType;
}

export interface SchemaEntry extends SchemaListEntry {
  base_url?: string;
  skip_archive?: boolean;
  order?: number;
  props: SchemaEntryProp[];
}

export interface SchemaObjectQuery {
  sort_key?: string;
  sort_direction?: string;
  term?: string;
  limit?: number;
  skip?: number;
}

export interface SchemaObjectEntry {
  id?: string;
  handle: string;
  created_at?: string;
  updated_at?: string;
}

export interface SchemaObjectQueryResult {
  count: number;
  items: SchemaObjectEntry[];
}

export interface SchemaObjectWalkResult {
  save: boolean;
  done?: boolean;
}

export class SchemaWrapper {
  private s: B2Schema;
  private handle: string;
  private schema: SchemaListEntry;

  constructor(schema: B2Schema, handle: string) {
    this.s = schema;
    this.handle = handle;
  }

  private async proxy<T>(
    fn: (schemaId: string, ...args: any[]) => Promise<T>,
    ...args: any[]
  ): Promise<T> {
    if (!this.schema) {
      const list = await this.s.listAllSchema();
      this.schema = list.find(s => s.handle === this.handle);
      if (!this.schema) {
        throw new Error(`Schema with handle '${this.handle}' was not found`);
      }
    }
    return fn.apply(this.s, [this.schema.id, ...args]);
  }

  async getSchema() {
    return this.proxy(this.s.getSchema);
  }

  async createSchema(schema: SchemaEntry): Promise<SchemaEntry> {
    return this.s.createSchema(schema);
  }

  async updateSchema(schema: SchemaEntry): Promise<SchemaEntry> {
    return this.s.updateSchema(schema);
  }

  async deleteSchema() {
    return this.proxy(this.s.deleteSchema);
  }

  async query(query: SchemaObjectQuery = {}) {
    return this.proxy(this.s.query, query);
  }

  async getObject(id: string) {
    return this.proxy(this.s.getObject, id);
  }

  async getObjects(ids: string[]) {
    return this.proxy(this.s.getObjects, ids);
  }

  async getObjectByHandle(handle: string) {
    return this.proxy(this.s.getObjectByHandle, handle);
  }

  async createObject(obj: SchemaObjectEntry) {
    return this.proxy(this.s.createObject, obj);
  }

  async updateObject(obj: SchemaObjectEntry) {
    return this.proxy(this.s.updateObject, obj);
  }

  async deleteObject(id: string) {
    return this.proxy(this.s.deleteObject, id);
  }

  async walkObjects(fn: WalkFunction, listObjectOnly: boolean = false) {
    return this.proxy(this.s.walkObjects, fn, listObjectOnly);
  }

  async walkAndUpdateObjects(fn: WalkUpdateFunction) {
    return this.proxy(this.s.walkAndUpdateObjects, fn);
  }
}

export type WalkFunction = (
  obj: SchemaObjectEntry,
  index: number,
  total: number
) => Promise<boolean | void>;
export type WalkUpdateFunction = (
  obj: SchemaObjectEntry,
  index: number,
  total: number
) => Promise<SchemaObjectWalkResult | void>;

const WALK_BATCH_SIZE = 100;
export class B2Schema {
  private c: B2Client;
  private path: string;

  constructor(
    client: B2Client,
    entryPath: string,
    public readonly isRef: boolean = false
  ) {
    this.c = client;
    this.path = `${entryPath}/schema`;
  }

  handle(handle: string): SchemaWrapper {
    return new SchemaWrapper(this, handle);
  }

  /** List all schemas */
  async listAllSchema(): Promise<SchemaListEntry[]> {
    return await this.c.request("GET", this.path + "/schema");
  }

  /** Get schema  */
  async getSchema(id: string): Promise<SchemaEntry> {
    return await this.c.request("GET", this.path + "/schema/" + id);
  }

  /** Create schema  */
  async createSchema(schema: SchemaEntry): Promise<SchemaEntry> {
    return await this.c.request("POST", this.path + "/schema", schema);
  }

  /** Update scehma */
  async updateSchema(schema: SchemaEntry): Promise<SchemaEntry> {
    return await this.c.request("PUT", this.path + "/schema", schema);
  }

  /** Delete scehma */
  async deleteSchema(schemaId: string) {
    return await this.c.request("DELETE", this.path + "/schema/" + schemaId);
  }

  /** Query schema objects */
  async query(
    schemaId: string,
    query: SchemaObjectQuery = {}
  ): Promise<SchemaObjectQueryResult> {
    return await this.c.request(
      "GET",
      this.c.url(this.path + "/schemaobject/" + schemaId, query)
    );
  }

  /** Get object */
  async getObject(schemaId: string, id: string): Promise<SchemaObjectEntry> {
    return await this.c.request(
      "GET",
      this.path + "/schemaobject/" + schemaId + "/" + id
    );
  }

  /** Get objects */
  async getObjects(
    schemaId: string,
    ids: string[]
  ): Promise<SchemaObjectEntry[]> {
    return await this.c.request(
      "POST",
      this.path + "/schemaobject/" + schemaId + "/get-all",
      ids
    );
  }

  /** Get object by handle */
  async getObjectByHandle(
    schemaId: string,
    handle: string
  ): Promise<SchemaObjectEntry> {
    return await this.c.request(
      "GET",
      this.path + "/schemaobject/" + schemaId + "/handle/" + handle
    );
  }

  /** Create object */
  async createObject(
    schemaId: string,
    obj: SchemaObjectEntry
  ): Promise<SchemaObjectEntry> {
    return await this.c.request(
      "POST",
      this.path + "/schemaobject/" + schemaId,
      obj
    );
  }

  /** Update object */
  async updateObject(
    schemaId: string,
    obj: SchemaObjectEntry
  ): Promise<SchemaObjectEntry> {
    return await this.c.request(
      "PUT",
      this.path + "/schemaobject/" + schemaId,
      obj
    );
  }

  /** Delete object */
  async deleteObject(schemaId: string, id: string) {
    return await this.c.request(
      "DELETE",
      this.path + "/schemaobject/" + schemaId + "/" + id
    );
  }

  /** Walk all objects */
  async walkObjects(
    schemaId: string,
    fn: WalkFunction,
    listObjectOnly: boolean = false
  ) {
    const r = await this.query(schemaId, {
      limit: WALK_BATCH_SIZE
    });
    const total = r.count;
    let offset = 0;
    let loadedItems = r.items;
    while (true) {
      for (let i = 0; i < loadedItems.length; i++) {
        const obj = listObjectOnly
          ? loadedItems[i]
          : await this.getObject(schemaId, loadedItems[i].id);
        const result = await fn(obj, offset + i, total);
        if (result === true) {
          return;
        }
      }

      offset += loadedItems.length;
      if (offset >= total) {
        break;
      }

      const { items, count } = await this.query(schemaId, {
        limit: WALK_BATCH_SIZE,
        skip: offset
      });
      if (count !== total) {
        throw new Error(
          `Number of schema object changed while walking. Expected ${total} but got ${count}`
        );
      }
      loadedItems = items;
    }
  }

  /** Walk object */
  async walkAndUpdateObjects(schemaId: string, fn: WalkUpdateFunction) {
    const self = this;
    await this.walkObjects(schemaId, async function(obj, i, n) {
      const r = await fn(obj, i, n);
      if (r) {
        const { save, done } = <SchemaObjectWalkResult>r;
        if (save) {
          await self.updateObject(schemaId, obj);
        }
        return done;
      }
    });
  }
}
