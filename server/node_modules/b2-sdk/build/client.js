"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const url = require("url");
const meta_1 = require("./meta");
class B2Client {
    constructor(config) {
        this.config = config;
    }
    get endpoint() {
        return this.config.endpoint;
    }
    url(path, query = {}) {
        const u = url.parse(path, true);
        u.query = Object.assign({}, u.query, query);
        return url.format(u);
    }
    configureQuery(query = {}) {
        query["auth_token"] = this.config.token;
        return query;
    }
    request(method, path, body = undefined, config = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `${this.config.endpoint}${path}`;
            return axios_1.default
                .request(Object.assign(Object.assign({}, config), { params: Object.assign(Object.assign({}, config.params), { auth_token: this.config.token }), method: method, url, data: body }))
                .then(res => {
                return res.data;
            }, err => {
                if (!err.response || !err.response.data) {
                    return Promise.reject({
                        status: 0,
                        method,
                        message: err.message || `Internal error`,
                        url,
                        body: null
                    });
                }
                const body = err.response.data;
                const status = err.response.status;
                return Promise.reject({
                    status,
                    url,
                    method,
                    message: body &&
                        typeof body === "object" &&
                        typeof body.message === "string"
                        ? body.message
                        : "Internal error",
                    body
                });
            });
        });
    }
    inspect() {
        return __awaiter(this, void 0, void 0, function* () {
            return meta_1.parseMeta(yield this.request("GET", "/b2.json"));
        });
    }
}
exports.B2Client = B2Client;
//# sourceMappingURL=client.js.map