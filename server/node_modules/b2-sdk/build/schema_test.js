"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const test = require("blue-tape");
const test_1 = require("./test");
const schema_1 = require("./schema");
const TEST_SCHEMA_ID = "b10749ac-5f35-40cf-9a3c-0af8c9e94b1f";
function getSchema() {
    return __awaiter(this, void 0, void 0, function* () {
        return new schema_1.B2Schema(yield test_1.getTestClient(), "/sdk_test");
    });
}
test("B2Schema.listAllSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const ss = yield s.listAllSchema();
        t.assert(Array.isArray(ss), "works");
    });
});
test("B2Schema.getSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const so = yield s.getSchema(TEST_SCHEMA_ID);
        t.assert(so && typeof so === "object", "works");
    });
});
test("B2Schema.createSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const so = yield s.getSchema(TEST_SCHEMA_ID);
        delete so.id;
        delete so.module_schema_id;
        delete so.table_name;
        delete so.created_at;
        delete so.updated_at;
        so.handle = `test_create_schema`;
        so.name = `Test createSchema`;
        const created = yield s.createSchema(so);
        t.deepEqual(created.props, so.props);
        yield s.deleteSchema(created.id);
    });
});
test("B2Schema.updateSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const so = yield s.getSchema(TEST_SCHEMA_ID);
        delete so.id;
        delete so.module_schema_id;
        delete so.table_name;
        delete so.created_at;
        delete so.updated_at;
        so.handle = `test_update_schema`;
        so.name = `Test updateSchema`;
        const created = yield s.createSchema(so);
        created.name = `Test updateSchema updated`;
        yield s.updateSchema(created);
        const updated = yield s.getSchema(created.id);
        t.equal(updated.name, created.name);
        yield s.deleteSchema(created.id);
    });
});
test("B2Schema.createObject", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_createObject"
        });
        yield s.deleteObject(TEST_SCHEMA_ID, obj.id);
        t.assert(obj && typeof obj === "object" && typeof obj.id === "string", "works");
    });
});
test("B2Schema.updateObject", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_updateObject",
            name: "original"
        });
        obj.name = "updated";
        yield s.updateObject(TEST_SCHEMA_ID, obj);
        const obj2 = yield s.getObject(TEST_SCHEMA_ID, obj.id);
        yield s.deleteObject(TEST_SCHEMA_ID, obj.id);
        t.equals(obj.name, "updated", "works");
    });
});
test("B2Schema.deleteObject", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_deleteObject"
        });
        yield s.deleteObject(TEST_SCHEMA_ID, obj.id);
        yield t.shouldFail(s.getObject(TEST_SCHEMA_ID, obj.id));
    });
});
test("B2Schema.getObject", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_getObject"
        });
        const obj2 = yield s.getObject(TEST_SCHEMA_ID, obj.id);
        yield s.deleteObject(TEST_SCHEMA_ID, obj.id);
        t.equals(obj2.id, obj.id, "works");
    });
});
test("B2Schema.getObjects", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj1 = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_getObjects1"
        });
        const obj2 = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_getObjects2"
        });
        const objs = yield s.getObjects(TEST_SCHEMA_ID, [obj1.id, obj2.id]);
        yield s.deleteObject(TEST_SCHEMA_ID, obj1.id);
        yield s.deleteObject(TEST_SCHEMA_ID, obj2.id);
        t.equals(objs.length, 2, "works");
    });
});
test("B2Schema.getObjectByHandle", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_getObjectByHandle"
        });
        const obj2 = yield s.getObjectByHandle(TEST_SCHEMA_ID, "test_getObjectByHandle");
        yield s.deleteObject(TEST_SCHEMA_ID, obj.id);
        t.equals(obj2.id, obj.id, "works");
    });
});
test("B2Schema.query", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const r = yield s.query(TEST_SCHEMA_ID);
        t.assert(r.count > 0 && r.items && Array.isArray(r.items), "works");
    });
});
test("B2Schema.walkObjects", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const { count } = yield s.query(TEST_SCHEMA_ID);
        let walked = 0;
        yield s.walkObjects(TEST_SCHEMA_ID, function (obj, i, n) {
            return __awaiter(this, void 0, void 0, function* () {
                walked++;
            });
        });
        t.equal(walked, count, "walked === count");
    });
});
test("B2Schema.walkAndUpdateObjects", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const obj = yield s.createObject(TEST_SCHEMA_ID, {
            handle: "test_walkAndUpdateObjects",
            name: "original"
        });
        yield s.walkAndUpdateObjects(TEST_SCHEMA_ID, function (o, i, n) {
            return __awaiter(this, void 0, void 0, function* () {
                if (o.id == obj.id) {
                    o.name = "updated";
                    return { save: true, done: true };
                }
            });
        });
        const obj2 = yield s.getObject(TEST_SCHEMA_ID, obj.id);
        yield s.deleteObject(TEST_SCHEMA_ID, obj.id);
        t.equals(obj2.name, "updated", "works");
    });
});
test("B2Schema.createSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const schema = yield s.createSchema({
            name: "SDK Created",
            handle: "sdk_created",
            props: [{ key: "id", type: schema_1.DataType.string, label: "ID" }]
        });
        t.assert(typeof schema.id === "string", "has id");
        t.assert(typeof schema.created_at === "string", "has created_at");
        yield s.deleteSchema(schema.id);
    });
});
test("B2Schema.updateSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const schema = yield s.createSchema({
            name: "SDK updateSchema",
            handle: "sdk_updateSchema",
            props: [{ key: "id", type: schema_1.DataType.string, label: "ID" }]
        });
        const updated = yield s.updateSchema(Object.assign({}, schema, {
            name: "Updated"
        }));
        t.equal(updated.name, "Updated", "name updated");
        yield s.deleteSchema(schema.id);
    });
});
test("B2Schema.deleteSchema", function (t) {
    return __awaiter(this, void 0, void 0, function* () {
        const s = yield getSchema();
        const schema = yield s.createSchema({
            name: "SDK deleteSchema",
            handle: "sdk_deleteSchema",
            props: [{ key: "id", type: schema_1.DataType.string, label: "ID" }]
        });
        yield s.deleteSchema(schema.id);
        t.shouldFail(s.getSchema(schema.id));
    });
});
//# sourceMappingURL=schema_test.js.map