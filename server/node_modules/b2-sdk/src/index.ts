import { B2Client } from "./client";
import { readConfig, B2Config } from "./config";
import { B2File, FileListEntry, FileEntry } from "./file";
import {
  B2Controller,
  ControllerListEntry,
  ControllerEntry
} from "./controller";
import { B2Schema } from "./schema";
import { B2Meta, Entry } from "./meta";
import { B2Archive } from "./archive";
import { B2Env } from "./env";
import { B2Asset } from "./asset";

export { FileListEntry, FileEntry, ControllerListEntry, ControllerEntry };

export class B2Entry {
  get name() {
    return this.meta.name;
  }

  private _path: string;
  get path() {
    return this._path;
  }

  private _file: B2File;
  get file() {
    return this._file;
  }

  private _controller: B2Controller;
  get controller() {
    return this._controller;
  }

  private _schema: B2Schema;
  get schema() {
    return this._schema;
  }

  private _env: B2Env;
  get env() {
    return this._env;
  }

  private _asset: B2Asset | null;
  get asset() {
    return this._asset;
  }

  constructor(c: B2Client, private meta: Entry, hasAsset: boolean) {
    let { path, refs } = meta;
    const isPageModuleRef = refs.includes("page");

    path = path === "/" ? "/__root" : path;
    this._path = path;
    this._file = new B2File(c, path, isPageModuleRef);
    this._controller = new B2Controller(c, path, isPageModuleRef);
    this._schema = new B2Schema(c, path, refs.includes("schema"));
    this._env = new B2Env(c, path, refs.includes("basics"));
    if (hasAsset) {
      this._asset = new B2Asset(c, `${path}/asset`);
    }
  }
}

export class B2 {
  private c: B2Client;
  private meta: B2Meta;
  private entryMap: Map<string, B2Entry>;
  private _archive: B2Archive;
  private _asset: B2Asset;

  constructor(config: B2Config) {
    this.c = new B2Client(config);
    this._archive = new B2Archive(this.c);
    this._asset = new B2Asset(this.c);
    this.entryMap = new Map<string, B2Entry>();
  }

  async init() {
    this.meta = await this.c.inspect();
    this.meta.entries.forEach(entry => {
      const asset = this.meta.allModules["asset"].find(
        a =>
          a.path === entry.path || (a.path === "__root" && entry.path === "/")
      );
      this.entryMap.set(entry.name, new B2Entry(this.c, entry, !!asset));
    });
  }

  get publicURL() {
    return this.meta.publicURL;
  }

  get entries() {
    return this.meta.entries;
  }

  get name() {
    return this.meta.name;
  }

  get referencedModules() {
    return this.meta.referencedModules;
  }

  get modules() {
    return this.meta.allModules;
  }

  get archive() {
    return this._archive;
  }

  get asset() {
    return this._asset;
  }

  entry(name: string) {
    const e = this.entryMap.get(name);
    if (!e) {
      const names = Array.from(this.entryMap.keys())
        .map(name => `'${name}'`)
        .join(", ");
      throw new Error(
        `Entry '${name}' was not found. Avaliable entries are: ${names}`
      );
    }
    return e;
  }
}

/** connect to a B2 instance */
export async function connect(config: string | B2Config): Promise<B2> {
  let b2: B2;
  if (typeof config === "string") {
    b2 = new B2(await readConfig(config));
  } else {
    b2 = new B2(config);
  }
  await b2.init();
  return b2;
}
