export interface ModuleMeta {
  type: string;
  version: string;
  metadata: any;
}

interface AppMeta {
  name: string;
  version: string;
  basePublicURL: string;
  env: string;
  modules: ModuleMeta[];
}

export interface ReferencedModules extends ModuleMeta {
  paths: string[];
}

export interface ModuleInstance {
  id?: string;
  path?: string;
  metadata: any;
}

export interface Entry {
  name: string;
  path: string;
  modules: string[];
  refs: string[];
}

export class B2Meta {
  private meta: AppMeta;
  private _referencedModules: ReferencedModules[];
  private _allModules: { [key: string]: ModuleInstance[] };
  private childApps: Entry[];

  constructor(data: any) {
    this.meta = data;
    this._referencedModules = [];
    this._allModules = {};
    this.childApps = [];
    this.findModules(this.meta);
  }

  get name() {
    return this.meta.name;
  }

  get publicURL() {
    return this.meta.basePublicURL;
  }

  get referencedModules() {
    return this._referencedModules;
  }

  get allModules() {
    return this._allModules;
  }

  get entries() {
    return this.childApps;
  }

  private findModules(app: AppMeta, path: string = "") {
    app.modules.forEach(m => {
      let um = this._referencedModules.find(um => um.type === m.type);
      if (!um) {
        um = Object.assign({}, m, { paths: [] });
        this._referencedModules.push(um);
      }

      um.paths.push(path);

      let il: ModuleInstance[];
      if (m.type in this._allModules) {
        il = this._allModules[m.type];
      } else {
        il = [];
        this._allModules[m.type] = il;
      }
      il.push({ id: m.metadata["id"], path, metadata: m.metadata });

      if (m.type === "composer") {
        let childApp: AppMeta;
        const entries: any = m.metadata["entries"];
        Object.keys(entries).forEach(childPath => {
          const mergedPath = path + (childPath === "/__root" ? "/" : childPath);
          const childApp: AppMeta = entries[childPath];
          this.childApps.push({
            name: childApp.name,
            path: mergedPath,
            modules: childApp.modules.map(m => m.type),
            refs: childApp.modules.reduce((list, m) => {
              if (m.metadata.$ref) {
                return [...list, m.type];
              } else {
                return list;
              }
            }, [])
          });
          this.findModules(childApp, mergedPath);
        });
      }
    });
  }
}

export function parseMeta(data: any) {
  return new B2Meta(data);
}
