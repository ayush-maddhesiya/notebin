"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var DataType;
(function (DataType) {
    DataType["string"] = "string";
    DataType["number"] = "number";
    DataType["boolean"] = "boolean";
    DataType["array"] = "array";
    DataType["object"] = "object";
})(DataType = exports.DataType || (exports.DataType = {}));
var FormatterType;
(function (FormatterType) {
    FormatterType["date"] = "date";
    FormatterType["currency"] = "currency";
})(FormatterType = exports.FormatterType || (exports.FormatterType = {}));
var EditorType;
(function (EditorType) {
    EditorType["textbox"] = "textbox";
    EditorType["dropdown"] = "dropdown";
    EditorType["file"] = "file";
    EditorType["checkbox"] = "checkbox";
    EditorType["code"] = "code";
    EditorType["none"] = "none";
})(EditorType = exports.EditorType || (exports.EditorType = {}));
var GridSize;
(function (GridSize) {
    GridSize["size_1"] = "1";
    GridSize["size_2"] = "2";
    GridSize["size_3"] = "3";
    GridSize["size_4"] = "4";
    GridSize["size_5"] = "5";
    GridSize["size_6"] = "6";
    GridSize["size_7"] = "7";
    GridSize["size_8"] = "8";
    GridSize["size_9"] = "9";
    GridSize["size_10"] = "10";
    GridSize["size_11"] = "11";
    GridSize["size_12"] = "12";
    GridSize["size_default"] = "default";
})(GridSize = exports.GridSize || (exports.GridSize = {}));
class SchemaWrapper {
    constructor(schema, handle) {
        this.s = schema;
        this.handle = handle;
    }
    proxy(fn, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.schema) {
                const list = yield this.s.listAllSchema();
                this.schema = list.find(s => s.handle === this.handle);
                if (!this.schema) {
                    throw new Error(`Schema with handle '${this.handle}' was not found`);
                }
            }
            return fn.apply(this.s, [this.schema.id, ...args]);
        });
    }
    getSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.getSchema);
        });
    }
    createSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.s.createSchema(schema);
        });
    }
    updateSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.s.updateSchema(schema);
        });
    }
    deleteSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.deleteSchema);
        });
    }
    query(query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.query, query);
        });
    }
    getObject(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.getObject, id);
        });
    }
    getObjects(ids) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.getObjects, ids);
        });
    }
    getObjectByHandle(handle) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.getObjectByHandle, handle);
        });
    }
    createObject(obj) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.createObject, obj);
        });
    }
    updateObject(obj) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.updateObject, obj);
        });
    }
    deleteObject(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.deleteObject, id);
        });
    }
    walkObjects(fn, listObjectOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.walkObjects, fn, listObjectOnly);
        });
    }
    walkAndUpdateObjects(fn) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.proxy(this.s.walkAndUpdateObjects, fn);
        });
    }
}
exports.SchemaWrapper = SchemaWrapper;
const WALK_BATCH_SIZE = 100;
class B2Schema {
    constructor(client, entryPath, isRef = false) {
        this.isRef = isRef;
        this.c = client;
        this.path = `${entryPath}/schema`;
    }
    handle(handle) {
        return new SchemaWrapper(this, handle);
    }
    listAllSchema() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("GET", this.path + "/schema");
        });
    }
    getSchema(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("GET", this.path + "/schema/" + id);
        });
    }
    createSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("POST", this.path + "/schema", schema);
        });
    }
    updateSchema(schema) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("PUT", this.path + "/schema", schema);
        });
    }
    deleteSchema(schemaId) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("DELETE", this.path + "/schema/" + schemaId);
        });
    }
    query(schemaId, query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("GET", this.c.url(this.path + "/schemaobject/" + schemaId, query));
        });
    }
    getObject(schemaId, id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("GET", this.path + "/schemaobject/" + schemaId + "/" + id);
        });
    }
    getObjects(schemaId, ids) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("POST", this.path + "/schemaobject/" + schemaId + "/get-all", ids);
        });
    }
    getObjectByHandle(schemaId, handle) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("GET", this.path + "/schemaobject/" + schemaId + "/handle/" + handle);
        });
    }
    createObject(schemaId, obj) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("POST", this.path + "/schemaobject/" + schemaId, obj);
        });
    }
    updateObject(schemaId, obj) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("PUT", this.path + "/schemaobject/" + schemaId, obj);
        });
    }
    deleteObject(schemaId, id) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.c.request("DELETE", this.path + "/schemaobject/" + schemaId + "/" + id);
        });
    }
    walkObjects(schemaId, fn, listObjectOnly = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const r = yield this.query(schemaId, {
                limit: WALK_BATCH_SIZE
            });
            const total = r.count;
            let offset = 0;
            let loadedItems = r.items;
            while (true) {
                for (let i = 0; i < loadedItems.length; i++) {
                    const obj = listObjectOnly
                        ? loadedItems[i]
                        : yield this.getObject(schemaId, loadedItems[i].id);
                    const result = yield fn(obj, offset + i, total);
                    if (result === true) {
                        return;
                    }
                }
                offset += loadedItems.length;
                if (offset >= total) {
                    break;
                }
                const { items, count } = yield this.query(schemaId, {
                    limit: WALK_BATCH_SIZE,
                    skip: offset
                });
                if (count !== total) {
                    throw new Error(`Number of schema object changed while walking. Expected ${total} but got ${count}`);
                }
                loadedItems = items;
            }
        });
    }
    walkAndUpdateObjects(schemaId, fn) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = this;
            yield this.walkObjects(schemaId, function (obj, i, n) {
                return __awaiter(this, void 0, void 0, function* () {
                    const r = yield fn(obj, i, n);
                    if (r) {
                        const { save, done } = r;
                        if (save) {
                            yield self.updateObject(schemaId, obj);
                        }
                        return done;
                    }
                });
            });
        });
    }
}
exports.B2Schema = B2Schema;
//# sourceMappingURL=schema.js.map